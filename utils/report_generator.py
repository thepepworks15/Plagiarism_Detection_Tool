"""
Report Generator Module
=======================
Generates highlighted plagiarism reports and PDF exports.

Features:
- HTML report with color-coded matched sections
- Professional PDF export using ReportLab
- AI-generated text detection results
- Summary statistics with visual indicators
"""

import os
import re
from datetime import datetime
from reportlab.lib import colors
from reportlab.lib.pagesizes import A4
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.platypus import (
    SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle,
    PageBreak, HRFlowable, Flowable
)
from reportlab.lib.enums import TA_CENTER, TA_LEFT, TA_JUSTIFY, TA_RIGHT


# ── Color Palette ──────────────────────────────────────────────
NAVY = colors.HexColor('#1a237e')
DARK_BLUE = colors.HexColor('#283593')
ACCENT_BLUE = colors.HexColor('#1565c0')
LIGHT_BG = colors.HexColor('#f5f7fa')
BORDER_GRAY = colors.HexColor('#dee2e6')
TEXT_GRAY = colors.HexColor('#6c757d')
SUCCESS = colors.HexColor('#28a745')
WARNING = colors.HexColor('#ffc107')
DANGER = colors.HexColor('#dc3545')
WHITE = colors.white


class ScoreIndicator(Flowable):
    """Custom flowable: a colored circle with the score percentage inside."""

    def __init__(self, score, size=80):
        Flowable.__init__(self)
        self.score = score
        self.size = size
        self.width = size
        self.height = size

    def draw(self):
        canvas = self.canv
        r = self.size / 2

        if self.score < 30:
            fill = SUCCESS
        elif self.score < 50:
            fill = WARNING
        else:
            fill = DANGER

        # Outer circle
        canvas.setFillColor(fill)
        canvas.circle(r, r, r, fill=1, stroke=0)

        # Inner white circle
        canvas.setFillColor(WHITE)
        canvas.circle(r, r, r - 4, fill=1, stroke=0)

        # Score text
        canvas.setFillColor(fill)
        canvas.setFont('Helvetica-Bold', 20)
        text = f"{self.score}%"
        tw = canvas.stringWidth(text, 'Helvetica-Bold', 20)
        canvas.drawString(r - tw / 2, r - 7, text)


class ColorBar(Flowable):
    """Custom flowable: horizontal progress bar."""

    def __init__(self, value, max_val=100, width=300, height=16):
        Flowable.__init__(self)
        self.value = min(value, max_val)
        self.max_val = max_val
        self.width = width
        self.height = height

    def draw(self):
        canvas = self.canv
        # Background bar
        canvas.setFillColor(colors.HexColor('#e9ecef'))
        canvas.roundRect(0, 0, self.width, self.height, 4, fill=1, stroke=0)

        # Filled bar
        fill_width = (self.value / self.max_val) * self.width
        if self.value < 30:
            color = SUCCESS
        elif self.value < 50:
            color = WARNING
        else:
            color = DANGER
        canvas.setFillColor(color)
        canvas.roundRect(0, 0, fill_width, self.height, 4, fill=1, stroke=0)

        # Percentage text on bar
        canvas.setFillColor(WHITE)
        canvas.setFont('Helvetica-Bold', 9)
        text = f"{self.value:.1f}%"
        tw = canvas.stringWidth(text, 'Helvetica-Bold', 9)
        if fill_width > tw + 10:
            canvas.drawString(fill_width - tw - 6, 3.5, text)


def _header_footer(canvas, doc):
    """Add header and footer to every page."""
    canvas.saveState()
    w, h = A4

    # Header line
    canvas.setStrokeColor(NAVY)
    canvas.setLineWidth(1.5)
    canvas.line(50, h - 40, w - 50, h - 40)
    canvas.setFont('Helvetica', 7)
    canvas.setFillColor(TEXT_GRAY)
    canvas.drawString(50, h - 35, "Plagiarism Detection Tool — Confidential Report")
    canvas.drawRightString(w - 50, h - 35, datetime.now().strftime('%B %d, %Y'))

    # Footer
    canvas.setStrokeColor(BORDER_GRAY)
    canvas.setLineWidth(0.5)
    canvas.line(50, 35, w - 50, 35)
    canvas.setFont('Helvetica', 8)
    canvas.setFillColor(TEXT_GRAY)
    canvas.drawString(50, 22, "Generated by Plagiarism Detection Tool")
    canvas.drawRightString(w - 50, 22, f"Page {doc.page}")

    canvas.restoreState()


class ReportGenerator:
    """Generates plagiarism analysis reports."""

    def __init__(self, output_dir='reports'):
        self.output_dir = output_dir
        os.makedirs(output_dir, exist_ok=True)

    def highlight_matches(self, text, matched_sentences):
        """
        Create HTML with highlighted matching sections.

        Args:
            text: Original document text
            matched_sentences: List of dicts with 'source_sentence' and 'similarity'

        Returns:
            str: HTML string with highlighted matches
        """
        if not matched_sentences:
            return f'<p>{self._escape_html(text)}</p>'

        html_text = self._escape_html(text)

        for match in matched_sentences:
            source = self._escape_html(match.get('source_sentence', ''))
            similarity = match.get('similarity', 0)

            if similarity > 0.9:
                bg_color = '#ff4444'
                label = 'High'
            elif similarity > 0.8:
                bg_color = '#ff8800'
                label = 'Medium'
            else:
                bg_color = '#ffcc00'
                label = 'Low'

            if source in html_text:
                highlighted = (
                    f'<span class="plagiarism-match" style="background-color: {bg_color}; '
                    f'padding: 2px 4px; border-radius: 3px;" '
                    f'title="Similarity: {similarity:.0%} ({label})">{source}</span>'
                )
                html_text = html_text.replace(source, highlighted, 1)

        return html_text

    def _escape_html(self, text):
        """Escape HTML special characters."""
        return (text
                .replace('&', '&amp;')
                .replace('<', '&lt;')
                .replace('>', '&gt;')
                .replace('"', '&quot;'))

    def _clean_text_for_pdf(self, text):
        """Clean text for safe inclusion in PDF."""
        if not text:
            return ''
        text = text.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
        text = re.sub(r'[\x00-\x08\x0b\x0c\x0e-\x1f]', '', text)
        return text

    def _build_styles(self):
        """Create all custom paragraph styles."""
        styles = getSampleStyleSheet()

        styles.add(ParagraphStyle(
            name='ReportTitle', parent=styles['Title'],
            fontSize=24, spaceAfter=6, textColor=NAVY,
            fontName='Helvetica-Bold'))
        styles.add(ParagraphStyle(
            name='ReportSubtitle', parent=styles['Normal'],
            fontSize=11, textColor=TEXT_GRAY, alignment=TA_CENTER,
            spaceAfter=20))
        styles.add(ParagraphStyle(
            name='SectionHead', parent=styles['Heading2'],
            fontSize=14, spaceAfter=10, spaceBefore=18,
            textColor=DARK_BLUE, fontName='Helvetica-Bold',
            borderPadding=(0, 0, 4, 0)))
        styles.add(ParagraphStyle(
            name='BodyCustom', parent=styles['Normal'],
            fontSize=9.5, leading=14, alignment=TA_JUSTIFY,
            fontName='Helvetica'))
        styles.add(ParagraphStyle(
            name='BodySmall', parent=styles['Normal'],
            fontSize=8, leading=11, fontName='Helvetica',
            textColor=TEXT_GRAY))
        styles.add(ParagraphStyle(
            name='CenterText', parent=styles['Normal'],
            fontSize=10, alignment=TA_CENTER))
        styles.add(ParagraphStyle(
            name='RightText', parent=styles['Normal'],
            fontSize=9, alignment=TA_RIGHT, textColor=TEXT_GRAY))
        styles.add(ParagraphStyle(
            name='MatchSource', parent=styles['Normal'],
            fontSize=8.5, leading=12, fontName='Helvetica',
            backColor=colors.HexColor('#fff3e0'),
            borderPadding=6, borderColor=colors.HexColor('#ffcc80'),
            borderWidth=0.5))
        styles.add(ParagraphStyle(
            name='MatchTarget', parent=styles['Normal'],
            fontSize=8.5, leading=12, fontName='Helvetica',
            backColor=colors.HexColor('#e3f2fd'),
            borderPadding=6, borderColor=colors.HexColor('#90caf9'),
            borderWidth=0.5))

        return styles

    def generate_pdf_report(self, analysis_results, doc1_name, doc2_name=None,
                            filename=None, ai_result=None):
        """
        Generate a professional PDF plagiarism report.

        Args:
            analysis_results: Dict containing all similarity analysis results
            doc1_name: Name of the primary document
            doc2_name: Name of the comparison document (if any)
            filename: Output filename (auto-generated if None)
            ai_result: AI detection result dict (optional)

        Returns:
            str: Path to the generated PDF file
        """
        if filename is None:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f'plagiarism_report_{timestamp}.pdf'

        filepath = os.path.join(self.output_dir, filename)
        doc = SimpleDocTemplate(
            filepath, pagesize=A4,
            topMargin=0.85 * inch, bottomMargin=0.7 * inch,
            leftMargin=0.75 * inch, rightMargin=0.75 * inch)

        styles = self._build_styles()
        elements = []

        score = analysis_results.get('overall_plagiarism_score', 0)
        classification = analysis_results.get('classification', 'N/A')

        # ────────────────────────────────────────────────
        # COVER / HEADER SECTION
        # ────────────────────────────────────────────────
        elements.append(Spacer(1, 20))
        elements.append(Paragraph('Plagiarism Detection Report', styles['ReportTitle']))
        elements.append(Paragraph(
            f'{doc1_name}' + (f' vs {doc2_name}' if doc2_name else ''),
            styles['ReportSubtitle']))
        elements.append(HRFlowable(
            width="100%", thickness=2, color=NAVY, spaceAfter=15))

        # Metadata table
        meta_data = [
            ['Report Date:', datetime.now().strftime('%B %d, %Y at %I:%M %p')],
            ['Document:', doc1_name],
        ]
        if doc2_name:
            meta_data.append(['Compared With:', doc2_name])

        meta_table = Table(meta_data, colWidths=[1.8 * inch, 4.7 * inch])
        meta_table.setStyle(TableStyle([
            ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
            ('FONTNAME', (1, 0), (1, -1), 'Helvetica'),
            ('FONTSIZE', (0, 0), (-1, -1), 9.5),
            ('TEXTCOLOR', (0, 0), (0, -1), DARK_BLUE),
            ('VALIGN', (0, 0), (-1, -1), 'TOP'),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 5),
            ('TOPPADDING', (0, 0), (-1, -1), 2),
        ]))
        elements.append(meta_table)
        elements.append(Spacer(1, 20))

        # ────────────────────────────────────────────────
        # OVERALL SCORE SECTION
        # ────────────────────────────────────────────────
        elements.append(Paragraph('Overall Plagiarism Score', styles['SectionHead']))

        if score < 30:
            score_hex = '#28a745'
        elif score < 50:
            score_hex = '#ffc107'
        else:
            score_hex = '#dc3545'

        score_indicator = ScoreIndicator(score, size=72)
        classification_para = Paragraph(
            f'<b>Classification:</b><br/>'
            f'<font size="13" color="{score_hex}"><b>{classification}</b></font>',
            styles['BodyCustom'])
        progress_bar = ColorBar(score, width=280, height=14)

        score_table = Table(
            [[score_indicator, classification_para, progress_bar]],
            colWidths=[1.3 * inch, 2.8 * inch, 2.4 * inch])
        score_table.setStyle(TableStyle([
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
            ('BACKGROUND', (0, 0), (-1, -1), LIGHT_BG),
            ('BOX', (0, 0), (-1, -1), 1, BORDER_GRAY),
            ('PADDING', (0, 0), (-1, -1), 12),
            ('ROUNDEDCORNERS', [6, 6, 6, 6]),
        ]))
        elements.append(score_table)
        elements.append(Spacer(1, 6))
        elements.append(Paragraph(
            '<font size="7.5" color="#9e9e9e">'
            'Scale: 0-15% Original | 15-30% Low | 30-50% Moderate | 50-75% High | 75%+ Very High'
            '</font>', styles['CenterText']))
        elements.append(Spacer(1, 20))

        # ────────────────────────────────────────────────
        # AI DETECTION SECTION (if available)
        # ────────────────────────────────────────────────
        if ai_result and ai_result.get('label') != 'unknown':
            elements.append(Paragraph('AI-Generated Text Detection', styles['SectionHead']))

            ai_conf = ai_result.get('confidence', 0) * 100
            ai_prob = ai_result.get('ai_probability', 0) * 100
            is_ai = ai_result.get('is_ai', False)

            ai_color = '#dc3545' if is_ai else '#28a745'
            ai_icon = 'AI-Generated' if is_ai else 'Human-Written'

            ai_data = [
                ['Verdict', 'Confidence', 'AI Probability', 'Human Probability'],
                [
                    Paragraph(f'<font size="11" color="{ai_color}"><b>{ai_icon}</b></font>',
                              styles['CenterText']),
                    Paragraph(f'<font size="11"><b>{ai_conf:.1f}%</b></font>',
                              styles['CenterText']),
                    Paragraph(f'<b>{ai_prob:.1f}%</b>', styles['CenterText']),
                    Paragraph(f'<b>{100 - ai_prob:.1f}%</b>', styles['CenterText']),
                ]
            ]
            ai_table = Table(ai_data, colWidths=[1.7 * inch, 1.5 * inch, 1.7 * inch, 1.6 * inch])
            ai_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), NAVY),
                ('TEXTCOLOR', (0, 0), (-1, 0), WHITE),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 9),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ('GRID', (0, 0), (-1, -1), 0.5, BORDER_GRAY),
                ('BACKGROUND', (0, 1), (-1, -1), LIGHT_BG),
                ('PADDING', (0, 0), (-1, -1), 10),
            ]))
            elements.append(ai_table)
            elements.append(Spacer(1, 20))

        # ────────────────────────────────────────────────
        # ALGORITHM BREAKDOWN
        # ────────────────────────────────────────────────
        elements.append(Paragraph('Algorithm Breakdown', styles['SectionHead']))

        cosine_val = analysis_results.get('cosine_similarity', 0)
        jaccard_val = analysis_results.get('jaccard_similarity', 0)
        ngram_val = analysis_results.get('ngram_analysis', {}).get('score', 0)
        semantic_val = analysis_results.get('semantic_similarity', {}).get('score', 0)

        def _score_cell(val):
            pct = val * 100
            if pct < 30:
                c = '#28a745'
            elif pct < 50:
                c = '#ffc107'
            else:
                c = '#dc3545'
            return Paragraph(f'<font size="12" color="{c}"><b>{pct:.1f}%</b></font>',
                             styles['CenterText'])

        algo_data = [
            ['Algorithm', 'Score', 'Weight', 'What it Measures'],
            [Paragraph('<b>Cosine Similarity</b><br/><font size="7" color="#888">(TF-IDF)</font>',
                        styles['BodyCustom']),
             _score_cell(cosine_val), '20%',
             'Angle between document TF-IDF vectors'],
            [Paragraph('<b>Jaccard Similarity</b><br/><font size="7" color="#888">(Set Overlap)</font>',
                        styles['BodyCustom']),
             _score_cell(jaccard_val), '30%',
             'Ratio of shared to total unique tokens'],
            [Paragraph('<b>N-gram Analysis</b><br/><font size="7" color="#888">(Trigrams)</font>',
                        styles['BodyCustom']),
             _score_cell(ngram_val), '50%',
             'Overlap of 3-word sequences'],
            [Paragraph('<b>Semantic Similarity</b><br/><font size="7" color="#888">(AI Embeddings)</font>',
                        styles['BodyCustom']),
             _score_cell(semantic_val),
             '45%*' if semantic_val > 0 else 'N/A',
             'Sentence meaning comparison using AI'],
        ]

        algo_table = Table(algo_data, colWidths=[2 * inch, 1 * inch, 0.8 * inch, 2.7 * inch])
        algo_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), NAVY),
            ('TEXTCOLOR', (0, 0), (-1, 0), WHITE),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 9),
            ('FONTSIZE', (0, 1), (-1, -1), 9),
            ('ALIGN', (1, 0), (2, -1), 'CENTER'),
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
            ('GRID', (0, 0), (-1, -1), 0.5, BORDER_GRAY),
            ('ROWBACKGROUNDS', (0, 1), (-1, -1), [WHITE, LIGHT_BG]),
            ('PADDING', (0, 0), (-1, -1), 8),
        ]))
        elements.append(algo_table)

        semantic_skipped = analysis_results.get('semantic_similarity', {}).get('skipped', False)
        if semantic_skipped:
            elements.append(Spacer(1, 4))
            elements.append(Paragraph(
                '<font size="7" color="#9e9e9e">'
                '* Semantic analysis was not enabled for this comparison. '
                'Weights shown are for non-semantic mode (Cosine: 20%, Jaccard: 30%, N-gram: 50%).'
                '</font>', styles['BodySmall']))
        else:
            elements.append(Spacer(1, 4))
            elements.append(Paragraph(
                '<font size="7" color="#9e9e9e">'
                '* When semantic analysis is enabled, weights are: '
                'Cosine 25%, Jaccard 15%, N-gram 15%, Semantic 45%.'
                '</font>', styles['BodySmall']))

        elements.append(Spacer(1, 15))

        # ────────────────────────────────────────────────
        # MATCHED SENTENCE PAIRS (SEMANTIC)
        # ────────────────────────────────────────────────
        semantic = analysis_results.get('semantic_similarity', {})
        matched_pairs = semantic.get('matched_pairs', [])
        if matched_pairs:
            elements.append(PageBreak())
            elements.append(Paragraph(
                'Matched Sentence Pairs (Semantic Analysis)', styles['SectionHead']))
            elements.append(Paragraph(
                f'Found <b>{len(matched_pairs)}</b> sentence pairs with similarity above 70%. '
                f'Showing top {min(len(matched_pairs), 15)} matches:',
                styles['BodyCustom']))
            elements.append(Spacer(1, 10))

            for i, pair in enumerate(matched_pairs[:15], 1):
                sim_pct = pair['similarity'] * 100
                if sim_pct > 90:
                    badge_color = '#dc3545'
                elif sim_pct > 80:
                    badge_color = '#ff8800'
                else:
                    badge_color = '#ffc107'

                elements.append(Paragraph(
                    f'<font size="9"><b>Match #{i}</b></font>'
                    f'  <font size="8" color="{badge_color}"><b>[{sim_pct:.1f}% similar]</b></font>',
                    styles['BodyCustom']))
                elements.append(Spacer(1, 3))

                source_text = self._clean_text_for_pdf(pair['source_sentence'][:350])
                match_text = self._clean_text_for_pdf(pair['matched_sentence'][:350])

                match_data = [
                    [Paragraph(f'<font size="7" color="#e65100"><b>SOURCE:</b></font><br/>'
                               f'<font size="8">{source_text}</font>', styles['BodyCustom']),
                     Paragraph(f'<font size="7" color="#1565c0"><b>MATCH:</b></font><br/>'
                               f'<font size="8">{match_text}</font>', styles['BodyCustom'])]
                ]
                match_table = Table(match_data, colWidths=[3.2 * inch, 3.2 * inch])
                match_table.setStyle(TableStyle([
                    ('VALIGN', (0, 0), (-1, -1), 'TOP'),
                    ('BACKGROUND', (0, 0), (0, 0), colors.HexColor('#fff8e1')),
                    ('BACKGROUND', (1, 0), (1, 0), colors.HexColor('#e3f2fd')),
                    ('BOX', (0, 0), (-1, -1), 0.5, BORDER_GRAY),
                    ('LINEBEFORE', (1, 0), (1, 0), 0.5, BORDER_GRAY),
                    ('PADDING', (0, 0), (-1, -1), 8),
                ]))
                elements.append(match_table)
                elements.append(Spacer(1, 8))

        # ────────────────────────────────────────────────
        # N-GRAM MATCHES
        # ────────────────────────────────────────────────
        ngram = analysis_results.get('ngram_analysis', {})
        matching_ngrams = ngram.get('matching_ngrams', [])
        if matching_ngrams:
            elements.append(Spacer(1, 10))
            elements.append(Paragraph('Matching N-grams (3-word Sequences)', styles['SectionHead']))
            elements.append(Paragraph(
                f'Found <b>{ngram.get("common_count", 0)}</b> common trigrams between documents '
                f'(Doc 1: {ngram.get("total_ngrams_doc1", 0)} trigrams, '
                f'Doc 2: {ngram.get("total_ngrams_doc2", 0)} trigrams).',
                styles['BodyCustom']))
            elements.append(Spacer(1, 8))

            # Show ngrams in a wrapped grid
            ngram_chips = []
            row = []
            for ng in matching_ngrams[:40]:
                row.append(Paragraph(
                    f'<font size="7" color="#555">{self._clean_text_for_pdf(ng)}</font>',
                    styles['CenterText']))
                if len(row) == 4:
                    ngram_chips.append(row)
                    row = []
            if row:
                while len(row) < 4:
                    row.append('')
                ngram_chips.append(row)

            if ngram_chips:
                ng_table = Table(ngram_chips, colWidths=[1.6 * inch] * 4)
                ng_table.setStyle(TableStyle([
                    ('BOX', (0, 0), (-1, -1), 0.5, BORDER_GRAY),
                    ('INNERGRID', (0, 0), (-1, -1), 0.3, colors.HexColor('#e0e0e0')),
                    ('BACKGROUND', (0, 0), (-1, -1), LIGHT_BG),
                    ('PADDING', (0, 0), (-1, -1), 5),
                    ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ]))
                elements.append(ng_table)

        # ────────────────────────────────────────────────
        # WEB SOURCES
        # ────────────────────────────────────────────────
        web_results = analysis_results.get('web_search', {})
        web_sources = web_results.get('sources', [])
        if web_sources:
            elements.append(PageBreak())
            elements.append(Paragraph('Online Sources Found', styles['SectionHead']))
            elements.append(Paragraph(
                f'The following <b>{len(web_sources)}</b> potential online sources were identified:',
                styles['BodyCustom']))
            elements.append(Spacer(1, 8))

            for i, source in enumerate(web_sources[:10], 1):
                title = self._clean_text_for_pdf(source.get('title', 'Untitled'))
                link = self._clean_text_for_pdf(source.get('link', ''))
                snippet = self._clean_text_for_pdf(source.get('snippet', ''))

                src_data = [[
                    Paragraph(f'<font size="9"><b>{i}. {title}</b></font><br/>'
                              f'<font size="7" color="#1565c0">{link}</font><br/>'
                              f'<font size="8" color="#666"><i>{snippet}</i></font>',
                              styles['BodyCustom'])
                ]]
                src_table = Table(src_data, colWidths=[6.4 * inch])
                src_table.setStyle(TableStyle([
                    ('BACKGROUND', (0, 0), (-1, -1), LIGHT_BG),
                    ('BOX', (0, 0), (-1, -1), 0.5, BORDER_GRAY),
                    ('PADDING', (0, 0), (-1, -1), 8),
                ]))
                elements.append(src_table)
                elements.append(Spacer(1, 6))

        # ────────────────────────────────────────────────
        # FOOTER DISCLAIMER
        # ────────────────────────────────────────────────
        elements.append(Spacer(1, 30))
        elements.append(HRFlowable(width="100%", thickness=1, color=BORDER_GRAY))
        elements.append(Spacer(1, 6))
        elements.append(Paragraph(
            '<font size="7" color="#9e9e9e">'
            'This report was generated automatically by the Plagiarism Detection Tool. '
            'Results should be reviewed by a qualified person before making any decisions. '
            'Similarity scores indicate textual overlap and do not necessarily imply plagiarism.'
            '</font>', styles['CenterText']))

        doc.build(elements, onFirstPage=_header_footer, onLaterPages=_header_footer)
        return filepath
